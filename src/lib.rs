use convert_case::{Case, Casing};
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Attribute, Data, DeriveInput, Lit, Meta, NestedMeta};

/// Derives the `as_static_str` method for an enum.
///
/// This macro generates an `as_static_str` method for each variant of the enum, which returns a static string
/// representation of the enum variant. The string can be customized using optional prefix and suffix attributes.
///
/// # Attributes
///
/// - `#[static_str(prefix = "...")]`: Optional. Specifies a prefix for all strings.
/// - `#[static_str(suffix = "...")]`: Optional. Specifies a suffix for all strings.
/// - `#[strum(serialize_all = "...")]`: Optional. Specifies the case conversion for variant names.
///
/// # Example
///
/// ```
/// use strum::EnumString;
/// use derive_static_str::{static_str, DeriveStaticStr};
///
/// #[derive(EnumString, DeriveStaticStr)]
/// #[static_str(prefix = "my_prefix_", suffix = "_suffix")]
/// #[strum(serialize_all = "snake_case")]
/// enum MyEnum {
///     VariantOne,
///     VariantTwo,
/// }
///
/// assert_eq!(MyEnum::VariantOne.as_static_str(), "my_prefix_variant_one_suffix");
/// assert_eq!(MyEnum::VariantTwo.as_static_str(), "my_prefix_variant_two_suffix");
/// ```
///
/// Without prefix and suffix:
///
/// ```
/// use strum::EnumString;
/// use derive_static_str::{static_str, DeriveStaticStr};
///
/// #[derive(EnumString, DeriveStaticStr)]
/// #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
/// enum AnotherEnum {
///     FirstVariant,
///     SecondVariant,
/// }
///
/// assert_eq!(AnotherEnum::FirstVariant.as_static_str(), "FIRST_VARIANT");
/// assert_eq!(AnotherEnum::SecondVariant.as_static_str(), "SECOND_VARIANT");
/// ```
///
/// # Panics
///
/// This macro will panic if used on anything other than an enum.
#[proc_macro_derive(DeriveStaticStr, attributes(path_str))]
pub fn derive_static_str(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;

    let prefix = get_attr_value(&input.attrs, "prefix").unwrap_or_else(|| "".to_string());
    let suffix = get_attr_value(&input.attrs, "suffix").unwrap_or_else(|| "".to_string());

    let serialize_all = get_strum_serialize_all(&input.attrs);
    let path_str_impl = impl_path_str(name, &input.data, &prefix, &suffix, serialize_all);

    let expanded = quote! {
        impl #name {
            pub fn as_static_str(&self) -> &'static str {
                #path_str_impl
            }
        }
    };

    TokenStream::from(expanded)
}

/// A marker attribute for use with `DeriveStaticStr`.
///
/// This attribute is used to specify the prefix and suffix for the `as_static_str` method
/// generated by `DeriveStaticStr`. It doesn't modify the input and is only used as a
/// marker for the derive macro.
#[proc_macro_attribute]
pub fn static_str(_args: TokenStream, input: TokenStream) -> TokenStream {
    // This attribute doesn't modify the input, it's just a marker
    input
}

fn impl_path_str(
    name: &syn::Ident,
    data: &Data,
    prefix: &str,
    suffix: &str,
    serialize_all: Option<String>,
) -> proc_macro2::TokenStream {
    match *data {
        Data::Enum(ref data) => {
            let match_arms = data.variants.iter().map(|variant| {
                let ident = &variant.ident;
                let variant_name = if let Some(ref case) = serialize_all {
                    match case.as_str() {
                        "PascalCase" => ident.to_string().to_case(Case::Pascal),
                        "SCREAMING_SNAKE_CASE" | "UPPERCASE" => {
                            ident.to_string().to_case(Case::ScreamingSnake)
                        }
                        "TRAIN-CASE" => ident.to_string().to_case(Case::Train),
                        "Title Case" => ident.to_string().to_case(Case::Title),
                        "camelCase" => ident.to_string().to_case(Case::Camel),
                        "kebab-case" => ident.to_string().to_case(Case::Kebab),
                        "lowercase" => ident.to_string().to_lowercase(),
                        "snake_case" => ident.to_string().to_case(Case::Snake),
                        _ => ident.to_string(),
                    }
                } else {
                    ident.to_string()
                };
                let path = if prefix.is_empty() && suffix.is_empty() {
                    variant_name
                } else {
                    format!("{}{}{}", prefix, variant_name, suffix)
                };
                quote! {
                    #name::#ident => #path,
                }
            });

            quote! {
                match self {
                    #(#match_arms)*
                }
            }
        }
        _ => panic!("DeriveStaticStr only supports enums"),
    }
}

fn get_strum_serialize_all(attrs: &[Attribute]) -> Option<String> {
    attrs
        .iter()
        .filter(|attr| attr.path.is_ident("strum"))
        .find_map(|attr| {
            if let Ok(Meta::List(meta_list)) = attr.parse_meta() {
                meta_list.nested.iter().find_map(|nested_meta| {
                    if let NestedMeta::Meta(Meta::NameValue(name_value)) = nested_meta {
                        if name_value.path.is_ident("serialize_all") {
                            if let Lit::Str(lit_str) = &name_value.lit {
                                return Some(lit_str.value());
                            }
                        }
                    }
                    None
                })
            } else {
                None
            }
        })
}

fn get_attr_value(attrs: &[Attribute], key: &str) -> Option<String> {
    attrs
        .iter()
        .filter(|attr| attr.path.is_ident("static_str"))
        .find_map(|attr| {
            if let Ok(Meta::List(meta_list)) = attr.parse_meta() {
                meta_list.nested.iter().find_map(|nested_meta| {
                    if let NestedMeta::Meta(Meta::NameValue(name_value)) = nested_meta {
                        if name_value.path.is_ident(key) {
                            if let Lit::Str(lit_str) = &name_value.lit {
                                return Some(lit_str.value());
                            }
                        }
                    }
                    None
                })
            } else {
                None
            }
        })
}
